'''This cell is to initiate the random atom generator and create bond, atom and veret lists'''
import random

#1. create a random amount of particles

import numpy.ma as ma

import numpy as np

def random_atoms( n, b ):
    '''generates random positions of atoms 
    INPUTS
    n - no. of atoms 
    b - volume size of simulation
    
    OUTPUTS
    pos - generates random list of atoms
    '''
    
    pos=[]

    
    for s in range (0,n): #for the number of atoms being put in the simulation
    #'Type in positions of atoms, in the form [x,y,z] seperating each position atom with a ,')))
    
        phi = 2*np.pi*np.random.rand() #using polar axis
    
        theta = np.pi*np.random.rand() #using polar axis
        
        posi=[b*np.random.rand()*np.sin(theta)*np.cos(phi), b*np.random.rand()*np.sin(theta)*np.sin(phi), b*np.random.rand()*np.cos(theta)] #random.randint(0,boundary), random.randint(0,boundary),random.randint(0,boundary)

        pos.append(posi) #adding the coordinates into the pos list.
        
    return pos

def bond_list(nAtoms,nBeads):
    
    '''generates a polymer bond list based on the atoms generated in the random_atoms function
    This function takes every nBeads of atoms in the atomlist generated by random_atoms and finds its neighbours and bonds them together by putting them in a sublsist. The program finds the atoms in the poolymers
    that are bonded to two other atoms, and the atoms on the end. The index of the sublist in the bond_list indicates the index of the atom in the pos atomlist.
    INPUT:
    
    nBeads - no. of beads for each polymer
    
    pos - atomlist from random_atoms

    Output:

    polymer - list of the indices of all the atoms and the polymer that they're in '''
    
    polymer = []
    
    
    for g in range(nAtoms):
            
            if g % nBeads == 0: #start of the chain  
                    
                polymer.append([g+1])


            elif (g+1) % nBeads == 0: #end of the chain
                

                polymer.append([g-1])
                
            elif g == nBeads -1: #used if nBeads doesn't fit into pos evenly, so should make the last atom an end atom.
                
                polymer.append([g-1])

            else:   ##has two neighbours

                polymer.append([g-1,g+1])
                

    return polymer


def angle_list(nAtoms,nBeads):
    
    ''' Gives index of all the the triplets of atoms that are bonded to each other within their polymers
    e.g [0,1,2], [1,2,3], [2,3,4] for the first polymer if nBeads is 5
    
    This is used to calculate the angle between atoms
    
    INPUT:
    
    nBeads - no. of beads per polymer
    
    nAtoms - no. of atoms int he simulation
    
    
    OUTPUT:
    anglelist - list of all the triplets of atoms that are bonded to eah other.
    
    '''

    anglelist = []
    store = []
    y = 0
    x = 0
    n = 1

    while x < nAtoms:

        store.append(x)
        
        
        x += 1


        if len(store) == 3:

            if x == n*nBeads :

                x += 2

                n += 1

            x-= 2

            anglelist.append(store)

            store = []
        
    return anglelist

def bondpair(nAtoms,nBeads):
    
    '''generates a polymer bond list based on the atoms generated in the random_atoms function. The function puts all the pairs of atoms that are bonded to each other 
    withour repetiion e.g [0,1] and [1,0] are the same.

    INPUT:
    
    nBeads - no. of beads for each polymer
    
    pos - atomlist from random_atoms

    Output:

    polymer - list of the indices of all the atoms and the polymer that they're in '''
    
    polymer = []
    
    
    for g in range(nAtoms):
            
            if g % nBeads == 0: #start of the chain  
                    
                polymer.append([g,g+1])


            elif (g+1) % nBeads == 0: #end of the chain

                continue
          #  elif g == nAtoms -1: #used if nBeads doesn't fit into pos evenly, so should make the last atom an end atom.
                
             #   polymer.append([g-1])

            else:   ##has two neighbours

                polymer.append([g,g+1])
                

    return polymer
    
#3. choose a particle  
def choose(nAtoms):
    ''' Chooses a random atom in the list
    INPUT:
    pos - the atom list 

    OUTPUT:
    i - the position of the randomly chosen atom'''

    i = np.random.randint( 0, nAtoms )
    
    return i

# calculate distance between the atoms 

# calculate distance between the atoms 


def distIndexPBC( i, j): #function with inputs i,j where i is atom in question and j. Measures deiscnae
        '''Calculate distance'''
        ii = np.array( i ) #turns atom i's position into a matrix
        jj = np.array( j ) #turns atom j's position into a matrix to be used below
        #dont use np.abs = square and square root the cooridnates 
        dx = np.sqrt((( ii - jj )**2).sum()) #gives dx , minus the matrices from each other
        
        return dx
#neighbourlist function, gives you list of atoms, according to their position in the atomlist (random_atom).

#4. create a verlet list of its neigbours
def nblist(i,pos,q):
    '''Creates a neighbourlist by calculating the distance between one atom and the other atoms in the atom list
    
    INPUT:
    i - index of random atom
    q - radius of the neighbour list/verlet list
    pos - list of atoms
    
    OUTPUT:
    
    neighbours - neighbourlist
    '''
    neighbours = []
    
    for j in range(0,len(pos)): 
    #In this way you avoid repeating looking for the same pair.
        if i != j: #could do i == j, but when using ip, ip isn't an index because it hasn't been accepted yet. 
            
            if distIndexPBC( pos[i], pos[j]) <= q: #This sets the distance an atom counts as a neighbour rcutoff + del set to 5 doesn't count itself.
            
                neighbours.append(j)
            
    return neighbours


#not get the atoms within the cutoff radius
'''This cell is to cross-link the polymer'''

def polymers_list(nAtoms,nBeads):
    
    ''' Gives index of all the polymer. Each sublist is one polymer.
    
    This is used to calculate the angle between atoms
    
    INPUT:
    
    nBeads - no. of beads per polymer
    
    nAtoms - no. of atoms int he simulation
    
    
    OUTPUT:
    polymerlist - list of all the of atoms for each polymer.
    
    '''

    polymerslist = []
    store = []
    
    x = 0
    n = 1

    while x < nAtoms:

        store.append(x)
        
        
        x += 1 #counter


        if len(store) == nBeads: #one polymer is counted, move on to next sublist for new polymer.

            if x == n*nBeads :

                x += 2 #so u can count triplets

                n += 1

            x-= 2 #

            polymerslist.append(store)

            store = []
        
    return polymerslist


#1 randomly choose middle atoms in polymer chain



    #2 randomly choose middle atoms from another polymer chain

def polychoose(polymerlist,nBeads):
    ''' Chooses two random atoms from two different polymers. Then checks if they're within a certain disatnce from each other. If they are, cross link them
    INPUT:
    
    nAtoms - no. of aotms
    
    nBeads - no. of beads
    
    polymerlist - list of indexes of atoms in their respective polymers (represented as sublists)
     

    OUTPUT:
    c1 - the position of the randomly chosen atom
    
    c2 - position of the second randomly chosen atom to be cross-linked with
    
    i1 - polymer no. chosen
    
    i2 - polyner no. chosen to cross link with polymer i1
    '''

    s = len(polymerlist) - 1 #because count from 0 - gives no. of polymers.

    i1 = random.randint(0,s) #choosing first polymer

    c1 = random.choice(polymerlist[i1]) #choosesn random atom from that polymer

    while c1 % nBeads == 0 or (c1+1) % nBeads == 0: #stop ends of polymers from being chosen.

        c1 = random.choice(polymerlist[i1])

        #continue

    i2 = random.randint(0,s)

    while i2 == i1: #prevent function from taking atom from the same polymer.

        i2 = random.randint(0,s)

        #continue

    c2 = random.choice(polymerlist[i2])

    while c2 % nBeads == 0 or (c2+1) % nBeads == 0: #stops ends of polymers from beign hcose

        c2 = random.choice(polymerlist[i2])
        
        #continue

    return [c1,c2], [i1,i2]

    
def x_link(polymerlist,pos,nBeads):

    '''Function that takes random atoms chosen to cross-link
    
    INPUT:
    
    nAToms - n. of atoms
    
    nBeads - no. of beads per polymer
    
    polymerlist - list of polymers with indexes of atoms within them
    
    pos - position lists of all the gerenated atoms
    
    OUTPUT:'''


 #3 compare distance between these two atoms, if less than critical distance, cross-link them
 #5 is abritraty  
    c = polychoose(polymerlist,nBeads) #choose the 2 random atoms from diff polymers

    cdist = distIndexPBC(pos[c[0][0]],pos[c[0][1]]) # calculate distance between the atoms
    
    return c,cdist
    

#print('bond list before append',blist)

#blist[c[0].append(c[1]) #cross-link p1 to p2 into bond list
#blist[c[1]].append(c[0]) #cross-link p2 to p1, put into bond list

#print('bond list after append',blist)

def xlink_polymer(nxlink,blist,polymerlist,pos,nBeads,step,badd,nx,clist,nstop):
    '''This function is used to cross link the polymers multiple times
    INPUT:
    nxlink - how many times do you want to cross link the polymera
    nx - no. of crosslinks currently.
    
    nstop - step at which crosslinking stops
    
    OUTPUT:
    
    blist - new bond list, including all the cross-links
    polymerlist - updated polymerlist
    
    badd - steps at which bonds weere added
    
    clist - pairs of polymers that have been crosslinked together
    '''
    
    for k in range(0,nxlink):
        
        l, cdist = x_link(polymerlist,pos,nBeads)
        
        if cdist < 5:
            
            c = l[0]

            clist.append(l[1])
            
            if len(blist[c[0]]) < 3 and len(blist[c[1]]) < 3: #prevent atom from being bonded cross-linked more than once because every middle atom is initially bonded to 2 other atoms. After a third is added, it means its cross linekd

                blist[c[0]].append(c[1]) #add atom 2 to atom 1's boond list
                blist[c[1]].append(c[0]) #add atom 1 to atom 2's bond list
                
                
                badd.append(step)
                
                nx += 1
                
    return blist,polymerlist,badd,nx, clist

'''This cell for the accept functions '''
#5. calculate dij = (Xi-xj) --distance betwen the partciles and its neighbour
import numpy as np

def xcheck(blist,nlinks,nxlink,polymerlist,pos,nBeads,step,badd,nx,clist,nstop):
            
    '''Checks if no. of intended cross-links has been fuilfilled
    INPUT:
            
    all inputs for xlinking fucnction
            
    nlink - no. of cross-links
            
    OUTPUT:
            
    blist - bond list
            
    polymerlist - polymer list
    
    bstep - list showing the steps at which crosslinking events occurs.'''
       
    
    if step < nstop:

        blist, polymerlist, badd, nx, clist = xlink_polymer(nxlink,blist,polymerlist,pos,nBeads,step,badd,nx,clist,nstop) #test
        
    return blist, polymerlist, badd , nx, clist



def distancefunction(posi,rclist,pos):
    
    ''' calculate distances between the atom and the different atoms in the neighbourlist
    
    INPUT
    
    posi - position of atom
    
    rclist - neighbourlist(vlist) or polymer bonding list(blist)
    
    pos - position list
    
    OUTPUT
    
    distlist - list of distances between i and other atoms in rclist'''
    
    distlist = [] #distances matrix
    

    for k in range( len(rclist) ):
        
       # print( 'HI',rclist[k] )

        dij = distIndexPBC(posi, pos[rclist[k]] )

        distlist.append(dij)

    return distlist 


#6. calculate Vij - energy between the 2 paritcles

#must first get the square of the distance


#distlit=np.array(distlist)
#dbdist=distlist**2 #dblist - double distances 
#calculate LJ potential
def LJFunction(r,eps,sigma ):
    
    '''Calculate the energy of the atom with respect to its position from other atoms in the neighbourlist
    
    INPUT
    r - distancelist
    eps - epsilon - depth of the potential well
    sigma - sigma, finite distance in which inter-particl potential is 0
    
    OUTPUT
    
    E - energy of the selected particle'''
    
    E = 0.0
    
    rCorrection = np.power( 2, 1.0 / 6.0 ) #cutoff - make LJ purely repulsive
    
    energyCorrection = 4*eps*( ( 1.0 / rCorrection)**12 - ( 1.0 / rCorrection)**6 ) #interaction with surface attractive part. Correct it so that r is normalised to rCrorrection
    #print('r before mask',r) #test
    
    E = ( 4*eps*( (sigma/r)**12-(sigma/r)**6 ) - energyCorrection )
    
    #print('E before mask',E)
    #print('r is ',r)
    for p in range(len(r)):
        
        if r[p] > rCorrection : #if any value in the distance list is greater than rCrorection, it is invalid. Basically if its attractive, its 0.
            
            E[p] = 0
         #test
            #print( rCorrection )
            
    #print('E after mask {0:1.10f}'.format(E))
    E = np.sum(E)
            #np.sum because if theres several elements, in r you want to sum all their energies
    return E     
             
          

#7. IF BONDED,  calculacte Vbond. # not sure how to implement this yet.
def bondpotential( rp,r0, k ):
    
    '''function that calculates the bond energy between atoms in the same polymer, which can be seen in the polymer list generated by p_generator
    INPUT:
    rp - polymer distance list, a list of the distances between atom i and the atoms int he same plymer
    k - spring constant, set to 1 at the moent for simplicty
    
    OUTpUT:
    H - harmonic, bond energy
    '''
              
    H = np.sum(0.5*k*((rp-r0)**2))
    
    #np.sum because if theres several elements, in r you want to sum all their energies
    
    return H


#8. calculate a random move -- use random walk algorithm random_walk

import random 
import math

def set_new_pos( posOld, b, dxMax):
    '''larger function used to random walk, then check if its within the boundaries of the simulation
    INPUT:
    
    posOld - old position of the chosen particle
    
    b - radius of boundary
    
    dxMax  - maximum displacement of the particle
    
    Output:
    
    ip - the new position of the atom
    
    '''
    
    ip = np.array( randomwalk( posOld, dxMax ) )#new random walk position

    if ( ((ip)**2).sum()  >  b**2) : # boundary conditions. if the x,y,or z coordinate lies outside this boundary, the atom is reset to its original position.

        ip = copy.copy(posOld)

    return ip

def randomwalk( posOld, dxMax ): #function that moves the chosen particle, Can only move by 1 each time

        ''' Function that does a random walk by choosing a random direction, then moves it by one step in that direction
        INPUT:
        posOld - copy of element i from pos(atom list)
        
        dxMax - maximum displacement

        OUTPUT:

        ip - new position oft he particle'''
        
        ran = dxMax * ( 0.5 - random.random() )
        
        index = random.randint( 0,2 )

        #ip = pos.copy()
        
        ip = copy.copy( posOld )
        
        ip[ index ] += ran

        return ip


#if delta i > delta /2 - recalcualte neighbourlist and obtain the energy calculation  from step 5 and 6.
#def acceptfunctoin(i,q,f,(randomwalk(i,q,f)),pos,vlist):


def delE(r,rp,r0,rf,rpf, eps,sigma, k):
    '''Functino that calculates the change in energy of the atom,
    LJ function is used to find the energy between atom i and all its neighbours in the niehgbourlist
    whilst Harmonic pornetial is used to find the energy between atom i and all the other atoms its bonded to from the polymer list
    
    INPUT:
    r - distance list - distances between atom i and all its neighbours
    rp - polymer distance list - distances between atom i and all its bonded atoms in its polymer chain
    eps - 1
    sigma - 1
    
    OUTPUT:
    
    delE - change in energy
    '''
    E = LJFunction( r,eps,sigma ) + bondpotential(rp,r0,k) #initial energy
    
    
    Ef = LJFunction( rf,eps,sigma ) + bondpotential(rpf,r0,k)  #new energy
    
    dE = Ef - E #change in potential energy (excluding bond energy for now) 
    
    return dE

def Acceptfunction(dE):
    
    '''Function nused to determine if the move is accepted or not
    
    INPUT: 
    dE - change in energy
    k - boltzman constant
    T = temperature 
    '''
        
    accept = False 
        
    if (dE < 0) :   #9.  if delta i(?) < delta/2 and if dE < 0 - accept move

        accept = True

    elif (dE > 0):
                #if rejected, revert back to previous neighbourlist
            #deltai remains the same
        if math.exp(-dE) > random.random(): #condition for acceptance when delE > 0 
                
            accept = True

    return accept

def totEnergy( pos, vlist, blist, nAtoms, bondLength, k, eps, sigma,q ):
    
    '''Calculates the total Leonard Jones potentail (E), Harmonic energy (H), and total energy (T = H + E), of every atom int he posiion tlist
    at that particular step
    
    INPUT:
    
    pos - position list
    
    vlist - verlet list
    
    blist - bond list
    
    nAtoms - no. of atoms
    
    k - spring constant
    
    eps - epsilon
    
    sigma - sigma
    
    
    OUTPUT:
    
    E - total LJ potnetial of all atoms at that time step
    
    H - total H potnetial of all atoms at that time step
    
    T - total energy of all atoms at that time step
    '''
    
    
    # sigma = myVar['sigma']
    
    E = 0.0
    H = 0.0
    T = 0.0
    
    for i in range(0,nAtoms):
        

        r = np.array(distancefunction(pos[i],vlist[i],pos)) 

        rp = np.array(distancefunction(pos[i],blist[i],pos)) 
        
        r0 = bondLength * ( np.ones( len( blist[i] ) ) )

        Ei = 0.5 * LJFunction(r,eps,sigma) # we put 0.5 because we double count the interactions

        Hi = 0.5 * bondpotential( rp,r0, k )  # we put 0.5 because we double count the bonds

        E += Ei

        H += Hi
                
        T = E + H 
    
    return E, H, T
            
from collections import defaultdict 

#Python code to merge all sublist having common elements. 
#merge function to  merge all sublist having common elements. 
def merge_common(lists): 
    neigh = defaultdict(set) 
    visited = set() 
    for each in lists: 
        for item in each: 
            neigh[item].update(each) 
    def comp(node, neigh = neigh, visited = visited, vis = visited.add): 
        nodes = set([node]) 
        next_node = nodes.pop 
        while nodes: 
            node = next_node() 
            vis(node) 
            nodes |= neigh[node] - visited 
            yield node 
    for node in neigh: 
        if node not in visited: 
            yield sorted(comp(node)) 

def clusters(polymerslist,Output,pos):
    cpos = [] #pos list for the different clusters. e.g index 1 in cpos is the pos list for all the atom sin cluster 1.

    #print('Cluster list is',Output)
    for p in range(len(Output)): #no. of clusters

        cpos.append([]) #e.g if there are 2 clusters, cpos will now have 2 empty lists

        #print('The polymers in Cluster {0} are = Output[p]= {1}'.format(i,Output[p]))

        for l in range(len(Output[p])): #p determiens the no. of clusters. This chooses the cluster. e.g p = 0, choose cluster 0

            #print('Choosing polymer {0} in cluster {1} using Output[p][l]'.format(Output[p][l],l))

            #print('The atoms in polymer {0} = polymerlist[Output[p][l]]= {1}'.format(Output[p][l],polymerslist[Output[p][l]]))

            for f in range(len(polymerslist[l])): # this chooses the atom list in the polymerlist (whcih corrseponds to the index of the atom in the pos list)

                #print('Choose atom {0} using polymerlist[Output[p][l]][f]'.format(polymerslist[Output[p][l]][f]))

                #print('The position of atom chosen atom {0} is using pos[polymerslist[Output[p][l]][f]] = {1}'.format(polymerslist[Output[p][l]][f],pos[polymerslist[Output[p][l]][f]]))

                cpos[p].append(pos[polymerslist[Output[p][l]][f]]) #adds positions of all the atoms in cluster p
                
    return cpos

'''THis cell is used to print the xyz file to be used in VMD
'''
def printMe( pos, fileNum ):
    '''Function that prints in file fileNum the position of nBeads in a .xyz format for visualisation'''
    
    nBeadsTot = len( pos ) 
    myFile = open(fileNum, 'a') #'a appends the file with whatever u want'
    
    myFile.write( str(nBeadsTot)  )
    myFile.write( '\n')
    
    myFile.write('\n')
    for i in range( nBeadsTot  ):
        
        myFile.write( 'C '  )
        
        t = np.array(pos[i])
        
        myFile.write(str(t).lstrip('[]').rstrip(']'))
        
        myFile.write('\n')
        
    myFile.close()
        
    return myFile

def print2(x,name):
    
    myFile = open(name,'a')
    
    myFile.write(str(x))
    
    myFile.write('\n')
    
    myFile.close()
    
    return myFile
def list_of_lists(input_list):
    test_list = []

    for x in input_list:
        test_list.append(np.ndarray.tolist(x))
    return test_list
        
#print(printMe(pos,'filNum.xyz'))

import random
import numpy as np
import copy


def MC(nStep,nAtoms,b,nBeads,nxlink,filename,nlinks,nstop):
    
    '''Monte carlo simulation, calling upon the monte_carlo_functions notebook, which containst the functions programmed to simulate this.
    zx
    INPUTS:list
    
    nStep - no. of steps you want the Monte Carlo to go through
    
    nAtoms = no. total particles
    
    b = radius of boundary
    
    nxlink - no. of crosslinks per cross-link event
    
    nlinks- total cross-links you want.
    
    OUTPUTS:
    
    Output1.xyz - an xyz file for visualisation
    
    '''
    
    
    # b isradius of the boundary. must be quoted or else it wont be defined int he program.
     
    pos = random_atoms(n=nAtoms,b=b) #atomlist n is number of atoms, b is the volume of the simulation
    
    polymerlist = polymers_list(nAtoms,nBeads)
    
    #constants = {'rc':3,'eps':1,'sigma':1,'k':1,'T':273,'kb':1/'T','q': 5}
    
   # constants2 = {'eps':1,'sigma':1,'l'}

    sigma = 1.0

    rc = sigma * np.power( 2, 1.0 / 6.0 ) #cutoff radius
    
    eps = 1.0 #to see if H and Ha(analytic) are eaul, set eps to 0, beacuse then theres no LJ
    
    k = 1.0 #spring constnat
    
    #kb*T = 1
    
    #T = 273.0
    
    #kb = 1.38*(10**-23)
    
    q = rc + sigma
    
    bondLength = 1.0
    
    badd = []
        
    n = []
    
    nr = []
    
    Eljt = [] #sum of all the LJ energies of each atom at a particular step

    Eht = [] #Harmonic bond potential lsit ofr all atoms
    
    Ett = [] #total energy for all atoms
    
    cE = [] #compare total energys with each other from diff measurement mthods.
    
    lastAccept = []
    
    Output = []
    
    Rg = []
    
    Rg_var = []
    
    clist = [] #list of pairs of polymers that have been crosslinked together
    
    polymerslist = polymers_list(nAtoms,nBeads)
    
    for m in range(len(polymerslist)): #makes sure to include clusters of singular polymers. e.g polymer 1 doesnt bond to any other
                    
        clist.append([m])
        
    blist = bond_list( nAtoms, nBeads ) # gives the indices of all the atoms that each atom is bonded to according to the position in t
    #the bonding list, which correspeonds to the positiion in the pos list
    
    step = 0
    
    nr = []
    
    vlist = []
    
    acounter = 0
    
    cpos = []
    
    nx = 0 #no. of crosslinks
    
    for i in range( nAtoms ):
        
        vlist.append( list( range(nAtoms) ) )
        
    for i in range( nAtoms ):
        vlist[ i ].pop(i)
        
    LJ, Harmonic, currentEnergy = totEnergy( pos,vlist, blist, nAtoms, bondLength, k, eps, sigma,q )
    
    print( "Initial Harmonic", Harmonic )
    print( "Initial LJ", LJ )
    print( "Initial Total", currentEnergy )
    #for i in range( nAtoms ):
        #print( i, pos[ i ] )
#make v list of atoms so its all of atoms 

    while step < nStep:
        
        rst = False
        
        accept = False
        
        i = choose(nAtoms)  # randonmly chosen atom

        r = np.array(distancefunction(pos[i],vlist[i],pos)) # calculate the distances between i and the other atoms in vlist. used to calculate the energy
        #vlist[i] because vlist is actually a large list with each sublist being a sublist of atom index i. so 0th index of vlist is the verlet list for atom 0.

        rp = np.array(distancefunction(pos[i],blist[i],pos)) #distance list - shows distances between atom i and the other atoms in the same polymer
        #used to calculate the harmonic bond potential between i and the other polymer atoms. 
        
        #print( "rp", rp )
        
        posOld = copy.copy( pos[ i ] )

        ip = set_new_pos(posOld,b,dxMax=0.5) # new posiiotn after random walk, with boundary condition
        
        rpf = np.array(distancefunction(ip,blist[i], pos)) #new polymer distance list
        
        #print( "rpf", rpf )
        
        #rf = np.array(distancefunction(ip,vlist[i], pos)) #new distacne function recalculated after random move
        
        pos[i] = copy.copy(ip)                
        
       # print('vlist before is',vlist)
        #print('vlist[i] before is ',i,vlist[i])
        #########
        #Check if we need to recalculate neighbour list BEFORE calculating
        
        ######## 
                
        rf = np.array(distancefunction(ip,vlist[i], pos)) #new distacne function recalculated after neighbourlist is recalculated.

        r0 = bondLength * np.ones( len( blist[i] ) )
    
        dE = delE(r,rp,r0,rf,rpf,eps,sigma,k)

        accept = Acceptfunction(dE) #running the acceptfunction, to see if the move was accepted or not
        
        step += 1
        
        if accept == True :
            
            currentEnergy += dE  

                #no need to recalculate vlist cuz its already recalculated above.
            acounter += 1
            
            #print(acounter)
            
        elif accept == False:
            
            pos[i] = copy.copy(posOld) #position list should be reset to before the move.
        
        if step%(200) == 0:
            
            blist, polymerslist, badd , nx, clist = xcheck(blist,nlinks,nxlink,polymerlist,pos,nBeads,step,badd,nx,clist,nstop)
            
            #assume highly dense crosslinking agent concentraiton
            
        if step % ( nStep/50 ) == 0:
            
            #energy plot
            cE.append( currentEnergy/nAtoms )

            #print( "Step", step ) #test
            
            printxyz = printMe(pos,str(filename))
            
            n.append(step)
            
            E, H, T = totEnergy( pos,vlist, blist, nAtoms, bondLength, k, eps, sigma, q )
            
            #print( 'compare', currentEnergy/nAtoms, T/nAtoms ) #test
                
            Eljt.append(E/nAtoms) #list of sums the lj potentials of all atoms
            
            Eht.append(H/nAtoms) #summing the h potnetials of all the aotms
            
            Ett.append(T/nAtoms) #list of the sums of the total energy of all atoms
            
                       #gyration radius
                
        if step % (nStep/100) == 0:
                
            Output = list(merge_common(clist)) 
            
            if step >= nstop: #only start measuring when crosslinking is complete 18 becaue thats when it usually stops crosslinking.
                '''cant do testing on simulations whne I put no limit to no. of crosslinks'''

                cpos = clusters(polymerslist,Output,pos)

                for l in range(len(cpos)): #finding Rg and Rgvar for each cluster. e.g if l = 0, Rg for cluster 0 is appended.

                    if len(cpos) != len(Rg): #on first measurment, Rg will be smaller than cpos, this is used to make it the same length
                        Rg = [] #reset Rg beacuse of the else: condition below. If enough crosslinking occurs, the previous Rg and Rgvar can be reset.
                        Rg_var = []
                        nr = [] # reset nr
                        for m in range(len(cpos)): #add emtpy lists to Rg for no. of clusters there are 
                                #e.g if there are 3 clusters, this will create 3 empty lists in Rg.
                            Rg.append([])
                            Rg_var.append([])

                    gyr = np.std(np.array(cpos[l]),axis = 0)

                    gyr = np.sqrt(((gyr )**2).sum()) #gives dx , minus the matrices from each other

                    Rg[l].append(gyr)
                    
                    

                    gyrvar = np.var(np.array(Rg[l]))

                    Rg_var[l].append(gyrvar)
                nr.append(step)
    

    pos = list_of_lists(pos)
    
    acceptrate = acounter/nStep
    
    print(acceptrate)
    
    return n,Eht, Eljt, Ett, blist, cE, Rg, Rg_var,badd, nx, Output,nr,pos

